/**
 * Perplexity Service for web research and information retrieval
 */
import axios from 'axios';
import logger from '../utils/logger.js';
import { RobustAPIClient } from '../utils/apiClient.js';
import { CircuitBreaker } from '../utils/monitoring.js';
import promptManager from './promptManager.js';

class PerplexityService {
  constructor() {
    this.apiKey = process.env.PERPLEXITY_API_KEY;
    this.models = {
      basic: 'sonar',         // For simple queries, now the default
      standard: 'sonar-pro',  // For complex queries (previously the default)
      deepResearch: 'sonar-deep-research' // For comprehensive research
    };
    this.searchModes = {
      basic: 'medium',     // Medium search context for basic queries with sonar
      standard: 'high',    // High search context for standard queries with sonar-pro
      deepResearch: 'high' // High search context for deep research with sonar-deep-research
    };
    // Maintain backward compatibility
    this.fallbackModels = ['sonar-pro', 'sonar'];
    this.fallbackConfig = {
      'sonar-deep-research': ['sonar-pro'],
      'sonar-pro': ['sonar']
    };
    this.isConnected = false;
    this.lastUsed = null;
    this.apiClient = new RobustAPIClient({
      maxRetries: 3,
      timeout: 180000, // 3 minutes for long-running research
      retryDelay: (retryCount) => Math.min(1000 * Math.pow(2, retryCount), 30000) // Exponential backoff capped at 30s
    });
    this.requestCounter = {
      timestamp: Date.now(),
      count: 0
    };
    this.circuitBreaker = new CircuitBreaker({
      failureThreshold: 3,
      resetTimeout: 300000 // 5 minutes
    });

    this.initialize();
  }

  initialize() {
    try {
      if (!this.apiKey) {
        logger.warn('Perplexity API key not found in environment variables');
        this.isConnected = false;

        // Log clear instructions for adding the API key
        logger.info('To enable Perplexity research functionality, add a PERPLEXITY_API_KEY to your environment or Replit secrets');
        return;
      }

      // Check if the API key appears to be valid (basic validation)
      if (this.apiKey.length < 20 || !this.apiKey.startsWith('pplx-')) {
        logger.warn('Perplexity API key appears to be invalid - should start with "pplx-" and be at least 20 characters');
        this.isConnected = false;
        return;
      }

      this.isConnected = true;
      logger.info('Perplexity service initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Perplexity service', { error: error.message });
      this.isConnected = false;
    }
  }

  /**
   * Get status of Perplexity service
   * @returns {Object} Service status information
   */
  getStatus() {
    return {
      service: 'Perplexity API',
      status: this.isConnected ? 'connected' : 'disconnected',
      lastUsed: this.lastUsed ? this.lastUsed.toISOString() : null,
      version: this.model,
      error: !this.isConnected ? 'API key not configured or service unavailable' : undefined
    };
  }

  /**
   * Perform research using Perplexity
   * @param {Array} messages - Array of message objects with role and content
   * @param {Object} options - Additional options for the research request
   * @returns {Promise<Object>} Research results
   */
  async performResearch(messages, options = {}) {
    if (!this.isConnected) {
      throw new Error('Perplexity service is not connected');
    }

    try {
      // Get the user query from the last message
      const userQuery = messages.filter(m => m.role === 'user').pop()?.content || '';
      
      // Log the raw query for debugging
      logger.info('Perplexity received raw query', { 
        query: userQuery,
        queryLength: userQuery.length 
      });
      
      // TEST: Directly check common patterns before any other processing
      // Check for stock price queries specifically
      const stockPricePattern = /stock price|price of stock|share price|stock value|current price|trading at/i;
      const isStockPriceQuery = stockPricePattern.test(userQuery);
      
      if (isStockPriceQuery) {
        logger.info('DETECTED STOCK PRICE QUERY', { 
          query: userQuery,
          matched: 'stock price pattern'
        });
        // Force the basic model for stock price queries
        options.model = this.models.basic;
      }
      
      // Weather pattern check
      const weatherPattern = /weather|forecast|temperature|rain|snow|climate|sunny|cloudy/i;
      const isWeatherQuery = weatherPattern.test(userQuery);
      
      if (isWeatherQuery) {
        logger.info('DETECTED WEATHER QUERY', { 
          query: userQuery,
          matched: 'weather pattern'
        });
        // Force the basic model for weather queries
        options.model = this.models.basic;
      }

      // Validate and prepare messages for the Perplexity API
      const validatedMessages = this.validateMessages(messages);

      // Add a more explicit system message for internet search
      validatedMessages.unshift({
        role: 'system', 
        content: 'You are a research assistant with real-time internet access. ALWAYS search the web for the most current information. Your primary goal is to provide up-to-date information with citations. Search broadly across different domains to find the most relevant and recent information.'
      });

      // Append current date instruction to the user query
      const lastMsgIndex = validatedMessages.findIndex(m => m.role === 'user' && validatedMessages.slice(validatedMessages.indexOf(m) + 1).every(n => n.role !== 'user'));

      if (lastMsgIndex !== -1) {
        validatedMessages[lastMsgIndex].content = `${validatedMessages[lastMsgIndex].content}\n\nPlease provide the most up-to-date information available as of today, March 24, 2025. I need CURRENT information.`;
      }

      // PRE-FILTER: First check if this is a stock price or weather query
      const stockPricePattern = /stock price|price of stock|share price|stock value|current price|trading at/i;
      const weatherPattern = /weather|forecast|temperature|rain|snow|climate|sunny|cloudy/i;
      
      // Create options object copy to avoid modifying original
      const modelOptions = {...options};
      
      // Directly override for common simple queries before the main model selection
      if (stockPricePattern.test(userQuery)) {
        logger.info('STOCK PRICE QUERY DETECTED - FORCING BASIC MODEL', {
          query: userQuery,
          forcedModel: this.models.basic
        });
        modelOptions.model = this.models.basic;
      } else if (weatherPattern.test(userQuery)) {
        logger.info('WEATHER QUERY DETECTED - FORCING BASIC MODEL', {
          query: userQuery,
          forcedModel: this.models.basic
        });
        modelOptions.model = this.models.basic;
      }
      
      // Enhanced request options
      // Determine which model to use based on query complexity
      const selectedModel = this.determineModelForQuery(userQuery, modelOptions);
      
      const requestOptions = {
        method: 'POST',
        url: 'https://api.perplexity.ai/chat/completions',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        data: {
          model: selectedModel,
          messages: validatedMessages,
          temperature: options.temperature || 0.1,
          max_tokens: options.maxTokens || 1024,
          top_p: options.topP || 0.9,
          search_domain_filter: options.domainFilter || [],
          search_recency_filter: "day",
          top_k: options.topK || 15,
          return_citations: true,
          frequency_penalty: 0.5,
          search_context_mode: options.searchContextMode || this.getSearchModeForModel(selectedModel)
        }
      };

      // Log the request with detailed model selection info
      logger.info('Sending enhanced request to Perplexity', {
        messageCount: requestOptions.data.messages.length,
        model: selectedModel, 
        recencyFilter: requestOptions.data.search_recency_filter,
        queryLength: userQuery.length,
        searchContextMode: requestOptions.data.search_context_mode
      });

      const response = await this.apiClient.request(requestOptions);
      this.lastUsed = new Date();

      // Log detailed information about the response
      const actualModel = response.data.model || selectedModel;
      logger.info('Perplexity API response received', { 
        citationsCount: (response.data.citations || []).length,
        contentLength: response.data.choices[0].message.content.length,
        promptTokens: response.data.usage?.prompt_tokens,
        completionTokens: response.data.usage?.completion_tokens,
        requestedModel: selectedModel,
        actualModel: actualModel,
        modelMatch: actualModel === selectedModel ? 'match' : 'mismatch'
      });

      // If there are no citations, log a warning
      if (!response.data.citations || response.data.citations.length === 0) {
        logger.warn('No citations returned from Perplexity - response may not include current information');
      } else {
        logger.info('Citations included in response', { 
          count: response.data.citations.length,
          sources: response.data.citations.slice(0, 3) // Log first few citations
        });
      }

      // Add explicit model information to the beginning of the response
      const originalResponse = response.data.choices[0].message.content;
      // Use the actual model from the response payload rather than the requested model
      const responseModel = response.data.model || requestOptions.data.model;
      const modelInfo = `[Using Perplexity AI - Model: ${responseModel}]\n\n`;
      const enhancedResponse = modelInfo + originalResponse;

      return {
        response: enhancedResponse,
        citations: response.data.citations || [],
        modelUsed: responseModel,
        usage: response.data.usage || { total_tokens: 0 }
      };
    } catch (error) {
      logger.error('Error in Perplexity research', { error: error.message });
      throw new Error(`Perplexity API error: ${error.message}`);
    }
  }

  /**
   * Perform deep research using Perplexity
   * @param {string} query - Research query
   * @param {string} jobId - Unique job identifier
   * @returns {Promise<Object>} Research results with sources
   */
  async performDeepResearch(query, jobId) {
    if (!this.isConnected) {
      throw new Error('Perplexity service is not connected');
    }

    try {
      logger.info(`Initiating deep research`, { jobId, queryLength: query.length });

      // Get and format the prompt
      const promptTemplate = await promptManager.getPrompt('perplexity', 'deep_research');
      let formattedQuery = promptManager.formatPrompt(promptTemplate, { query });

      // Add an explicit instruction for current information
      formattedQuery += `\n\nMake sure to include only the most current information available as of today, March 23, 2025. This research must be based on the latest available data.`;

      // Use circuit breaker pattern for the API call
      return await this.circuitBreaker.executeRequest('perplexity-deep', async () => {
        // Enhanced request settings for better search capabilities
        const requestOptions = {
          method: 'POST',
          url: 'https://api.perplexity.ai/chat/completions',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`
          },
          data: {
            model: this.models.deepResearch,
            messages: [
              { 
                role: 'system', 
                content: 'You are a research assistant with real-time internet access. Always search for and use the most recent information available. Your research should be comprehensive, up-to-date, and well-sourced with citations.'
              },
              { 
                role: 'user', 
                content: formattedQuery 
              }
            ],
            temperature: 0.1, // Lower temperature for more factual responses
            max_tokens: 1500, // Allow for longer, more detailed responses
            top_p: 0.95,
            top_k: 15,
            search_recency_filter: "day", // Most recent information
            search_domain_filter: [], // No domain restrictions
            return_citations: true,
            frequency_penalty: 0.5, // Keeping only frequency_penalty, removing presence_penalty
            stream: false, // We want the complete response at once
            search_context_mode: "high" // High search context mode for more comprehensive search
          }
        };

        logger.info('Deep research request configuration', {
          jobId,
          requestedModel: this.models.deepResearch,
          actualModel: requestOptions.data.model,
          recencyFilter: requestOptions.data.search_recency_filter
        });

        let response;
        try {
          response = await this.apiClient.request(requestOptions);
        } catch (error) {
          if (error.response?.status === 429 || error.response?.status === 503) {
            const currentModel = requestOptions.data.model;
            const fallbacks = this.fallbackConfig[currentModel] || [];

            for (const fallbackModel of fallbacks) {
              logger.info(`Attempting fallback to model ${fallbackModel}`, { jobId, originalModel: currentModel });
              requestOptions.data.model = fallbackModel;
              try {
                response = await this.apiClient.request(requestOptions);
                logger.info(`Successfully fell back to ${fallbackModel}`, { jobId });
                break;
              } catch (fallbackError) {
                logger.error(`Fallback to ${fallbackModel} failed`, { 
                  jobId,
                  error: fallbackError.message 
                });
              }
            }

            if (!response) {
              throw error; // If all fallbacks failed, throw original error
            }
          } else {
            throw error;
          }
        }

        const duration = Date.now() - response.config.timestamp;

        const actualModel = response.data.model || requestOptions.data.model;
        logger.info('Perplexity API response received', {
          duration: `${duration}ms`,
          citationsCount: (response.data.citations || []).length,
          jobId,
          requestedModel: this.models.deepResearch,
          actualModel: actualModel,
          modelMatch: actualModel === this.models.deepResearch ? 'match' : 'mismatch'
        });

        if (!response.data?.choices?.[0]?.message) {
          throw new Error('Invalid response format from Perplexity API');
        }

        const responseData = response.data.choices[0].message;

        // Log full citations for debugging
        if (response.data.citations && response.data.citations.length > 0) {
          logger.info('Citations from deep research', {
            jobId,
            citations: response.data.citations.slice(0, 5) // Log first 5 citations
          });
        } else {
          logger.warn('No citations returned from deep research', { jobId });
        }

        logger.info('Deep research completed successfully', {
          jobId,
          contentLength: responseData.content.length
        });

        // Add explicit model information to the beginning of the deep research response
        // Use the actual model from the response payload rather than the requested model
        const responseModel = response.data.model || requestOptions.data.model;

        // Verify model matches what we requested
        if (responseModel !== this.models.deepResearch) {
          logger.warn('Model mismatch in deep research', {
            requestedModel: this.models.deepResearch,
            actualModel: responseModel,
            jobId
          });
        }

        const modelInfo = `[Using Perplexity AI - Model: ${responseModel}]\n\n`;
        const enhancedContent = modelInfo + responseData.content;

        return {
          query: formattedQuery,
          timestamp: new Date().toISOString(),
          content: enhancedContent,
          sources: response.data.citations || [],
          modelUsed: responseModel,
          requestedModel: this.models.deepResearch,
          usage: response.data.usage || { total_tokens: 0 }
        };
      });
    } catch (error) {
      logger.error('Error performing deep research', {
        jobId,
        error: error.message
      });

      if (error.response?.data) {
        logger.error('Perplexity API error details', {
          jobId,
          status: error.response.status,
          data: error.response.data
        });
      }
      throw error;
    }
  }

  /**
   * Analyzes a query and determines which model should be used based on complexity
   * @param {string} query - The user query to analyze
   * @param {Object} options - Additional options that may override the default selection
   * @returns {string} The model name to use
   */
  determineModelForQuery(query, options = {}) {
    // If there's an explicit model override in options, use that
    if (options.model) {
      logger.info(`Using explicitly requested model: ${options.model}`);
      return options.model;
    }
    
    // Check for the complexity keywords that suggest using sonar-pro
    const complexityKeywords = [
      'detailed analysis', 'comprehensive', 'in-depth', 'deep dive',
      'technical explanation', 'complex', 'pros and cons', 'compare', 
      'evaluate', 'research', 'analyze', 'trends', 'statistical', 
      'explain the implications', 'historical context'
    ];
    
    // Check for keywords that suggest using the basic model
    const simpleQueryKeywords = [
      // Simple request indicators
      'simple', 'briefly', 'summary', 'quick', 'basic', 'short',
      'summarize', 'just tell me', 'in a few words', 'tldr', 
      
      // Question words and common simple queries
      'who is', 'when did', 'where is', 'what is', 'how much', 'tell me about',
      
      // Common information requests that should use basic model
      'stock price', 'stock market', 'exchange rate', 'weather', 'forecast',
      'temperature', 'sports score', 'news', 'current price', 'bitcoin',
      'crypto', 'capital of', 'population', 'recipe', 'how to'
    ];
    
    // Check if query contains complexity keywords
    const isComplex = complexityKeywords.some(keyword => 
      query.toLowerCase().includes(keyword.toLowerCase())
    );
    
    // Check if query explicitly asks for a simple response
    const isSimpleRequest = simpleQueryKeywords.some(keyword => 
      query.toLowerCase().includes(keyword.toLowerCase())
    );
    
    // Length-based heuristic - long queries tend to be more complex
    const isLongQuery = query.length > 150; // Increased threshold to avoid catching simple queries
    
    // Common simple queries that should use the basic model regardless of length
    const simpleQueryPatterns = [
      // Financial queries
      /stock price/i, /stock market/i, /exchange rate/i, /currency/i, /bitcoin/i, /crypto/i,
      
      // Weather and time queries
      /weather/i, /forecast/i, /temperature/i, /what time/i, /what day/i, /date today/i,
      
      // Sports and entertainment
      /sports score/i, /game score/i, /who won/i, /match result/i, /movie/i, /tv show/i,
      
      // Factual information
      /news/i, /define/i, /meaning of/i, /capital of/i, /population/i, /height of/i, /age of/i,
      
      // How-to and instructional 
      /how to/i, /how do I/i, /steps to/i, /recipe/i, /make a/i, /create a/i,
      
      // Simple questions
      /where is/i, /when was/i, /who is/i, /what is/i, /tell me about/i
    ];
    
    // Check if query matches common simple query patterns
    const isCommonSimpleQuery = simpleQueryPatterns.some(pattern => 
      pattern.test(query)
    );
    
    // Make the model decision, prioritizing common simple patterns
    if (isCommonSimpleQuery) {
      logger.info('Using basic model (sonar) for common simple query', {
        queryLength: query.length,
        isCommonSimpleQuery: true
      });
      return this.models.basic;
    } else if (isComplex || (isLongQuery && !isSimpleRequest)) {
      logger.info('Using standard model (sonar-pro) for complex query', {
        queryLength: query.length,
        isComplex,
        isLongQuery
      });
      return this.models.standard;
    } else if (isSimpleRequest) {
      logger.info('Using basic model (sonar) for simple query', {
        queryLength: query.length,
        isSimpleRequest
      });
      return this.models.basic;
    } else {
      // Default to the basic model, which is now 'sonar'
      logger.info('Using default basic model (sonar) for query', {
        queryLength: query.length
      });
      return this.models.basic;
    }
  }

  /**
   * Get the appropriate search mode for a given model
   * @param {string} model - The Perplexity model name
   * @returns {string} The search context mode to use
   */
  getSearchModeForModel(model) {
    // For sonar (basic model)
    if (model === this.models.basic) {
      return this.searchModes.basic;
    }
    
    // For sonar-pro (standard model) 
    if (model === this.models.standard) {
      return this.searchModes.standard;
    }
    
    // For sonar-deep-research (deep research model)
    if (model === this.models.deepResearch) {
      return this.searchModes.deepResearch;
    }
    
    // Default to medium mode if model isn't recognized
    return 'medium';
  }

  /**
   * Validate messages format for Perplexity API
   * Must alternate between user and assistant, ending with user
   * @param {Array} messages - Array of message objects with role and content
   * @returns {Array} Validated and possibly fixed messages array
   */
  validateMessages(messages) {
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return [{ role: 'user', content: 'Provide information on this topic.' }];
    }

    const validMessages = messages.map(msg => ({
      role: msg.role === 'user' ? 'user' : 'assistant',
      content: msg.content
    }));

    // Add a system message at the beginning if not present
    if (validMessages[0].role !== 'system') {
      validMessages.unshift({
        role: 'system',
        content: 'You are a helpful research assistant. Provide factual, well-sourced information.'
      });
    }

    // Ensure the sequence alternates properly and ends with a user message
    const fixedMessages = [];
    let lastRole = null;

    for (const msg of validMessages) {
      // Skip consecutive messages with the same role (except system messages)
      if (msg.role === lastRole && msg.role !== 'system') {
        continue;
      }

      fixedMessages.push(msg);
      lastRole = msg.role;
    }

    // If the last message is not from the user, add a user message
    if (fixedMessages[fixedMessages.length - 1].role !== 'user') {
      fixedMessages.push({
        role: 'user',
        content: 'Please provide information on this topic based on our conversation.'
      });
    }

    return fixedMessages;
  }
}

const perplexityService = new PerplexityService();
export default perplexityService;