// services/jobManager.js
const Bull = require('bull');
const logger = require('../utils/logger');
const { performance } = require('perf_hooks');
const redisClient = require('./redisClient');

class JobManager {
  constructor() {
    this.queues = {};
    this.monitorInterval = null;
  }
  
  createQueue(name, options = {}) {
    if (this.queues[name]) {
      return this.queues[name];
    }
    
    const defaultOptions = {
      redis: process.env.REDIS_URL,
      defaultJobOptions: {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 1000
        },
        removeOnComplete: 100, // Keep the latest 100 completed jobs
        removeOnFail: 100      // Keep the latest 100 failed jobs
      }
    };
    
    const queue = new Bull(name, { ...defaultOptions, ...options });
    
    // Add queue monitoring
    queue.on('error', (error) => {
      logger.error(`Queue ${name} error`, { error: error.message });
    });
    
    queue.on('stalled', (job) => {
      logger.warn(`Job ${job.id} in queue ${name} stalled`, { jobId: job.id });
    });
    
    queue.on('completed', (job, result) => {
      const processingTime = job.finishedOn - job.processedOn;
      logger.info(`Job ${job.id} in queue ${name} completed`, { 
        jobId: job.id, 
        duration: processingTime,
        attempts: job.attemptsMade
      });
    });
    
    queue.on('failed', (job, error) => {
      logger.error(`Job ${job.id} in queue ${name} failed`, { 
        jobId: job.id, 
        error: error.message,
        attempts: job.attemptsMade
      });
    });
    
    queue.on('waiting', (jobId) => {
      logger.debug(`Job ${jobId} in queue ${name} waiting`);
    });
    
    this.queues[name] = queue;
    return queue;
  }
  
  async enqueueJob(queueName, data, options = {}) {
    const queue = this.createQueue(queueName);
    logger.debug(`Enqueueing job in ${queueName}`, { data });
    
    const job = await queue.add(data, options);
    return job.id;
  }
  
  async getJobStatus(queueName, jobId) {
    const queue = this.createQueue(queueName);
    const job = await queue.getJob(jobId);
    
    if (!job) {
      return { status: 'not_found' };
    }
    
    let status = await job.getState();
    let progress = job._progress || 0;
    
    return { 
      id: job.id,
      status, 
      progress, 
      attempts: job.attemptsMade,
      data: job.data,
      createdAt: job.timestamp,
      processingTime: job.finishedOn ? job.finishedOn - job.processedOn : null,
      waitTime: job.processedOn ? job.processedOn - job.timestamp : null
    };
  }
  
  registerProcessor(queueName, processor, concurrency = 1) {
    const queue = this.createQueue(queueName);
    
    queue.process(concurrency, async (job, done) => {
      try {
        logger.info(`Processing job ${job.id} in queue ${queueName}`, { jobId: job.id });
        const start = performance.now();
        
        // Add progress reporting
        job.progress = function(percent) {
          job.updateProgress(percent);
        };
        
        const result = await processor(job);
        const duration = performance.now() - start;
        
        logger.info(`Job ${job.id} processing completed in ${duration.toFixed(0)}ms`, { 
          jobId: job.id,
          duration: duration.toFixed(0)
        });
        
        done(null, result);
      } catch (error) {
        logger.error(`Error processing job ${job.id} in queue ${queueName}`, { 
          jobId: job.id, 
          error: error.message,
          stack: error.stack
        });
        done(error);
      }
    });
    
    logger.info(`Registered processor for queue ${queueName} with concurrency ${concurrency}`);
    return queue;
  }
  
  startMonitoring() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
    }
    
    this.monitorInterval = setInterval(async () => {
      try {
        for (const [queueName, queue] of Object.entries(this.queues)) {
          const counts = await queue.getJobCounts();
          logger.debug(`Queue ${queueName} status`, { counts });
          
          // Alert on large backlogs
          if (counts.waiting > 100) {
            logger.warn(`Large backlog in queue ${queueName}`, { 
              waiting: counts.waiting 
            });
          }
          
          // Alert on failed jobs
          if (counts.failed > 10) {
            logger.warn(`High failure rate in queue ${queueName}`, { 
              failed: counts.failed 
            });
          }
        }
      } catch (error) {
        logger.error('Error in queue monitoring', { error: error.message });
      }
    }, 60000); // Check every minute
  }
  
  async recoverStuckJobs(queueName) {
    try {
      const queue = this.createQueue(queueName);
      
      // Get active jobs
      const activeJobs = await queue.getActive();
      let recovered = 0;
      
      // Check for jobs stuck in active state for too long (10 minutes)
      const stuckJobs = activeJobs.filter(job => {
        return Date.now() - job.processedOn > 10 * 60 * 1000;
      });
      
      if (stuckJobs.length > 0) {
        logger.warn(`Found ${stuckJobs.length} stuck jobs in ${queueName} queue`);
        
        // Retry each stuck job
        for (const job of stuckJobs) {
          await job.retry();
          recovered++;
          logger.info(`Recovered stuck job ${job.id} in ${queueName} queue`);
        }
      }
      
      return recovered;
    } catch (error) {
      logger.error(`Error recovering stuck jobs for ${queueName}`, { 
        error: error.message 
      });
      return 0;
    }
  }
  
  stop() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
    
    const closePromises = Object.values(this.queues).map(queue => {
      return queue.close();
    });
    
    return Promise.all(closePromises);
  }
}

module.exports = new JobManager();