To resolve the issue of duplicate WebSocket broadcast functions in your server/routes.ts file for a more robust testing environment, here's a fixed approach:

```javascript
/**
 * Unified function to broadcast messages through WebSockets
 * @param message The WebSocketMessage to broadcast
 * @param options Optional parameters for specialized broadcasting
 * @param options.roomNames Specific room names to broadcast to (defaults to message.type and 'all')
 * @param options.socketId Specific socket ID to send to (for direct client communication)
 */
function broadcastMessage(
  message: WebSocketMessage, 
  options?: { 
    roomNames?: string[],
    socketId?: string 
  }
) {
  if (!io || !message || !message.type) {
    console.warn('Cannot broadcast: missing io, message, or message type');
    return;
  }
  
  // Case 1: Send to specific client by socket ID
  if (options?.socketId) {
    io.to(options.socketId).emit('message', message);
    return;
  }
  
  // Case 2: Send to specific rooms
  if (options?.roomNames && options.roomNames.length > 0) {
    options.roomNames.forEach(room => {
      io.to(room).emit('message', message);
    });
    return;
  }
  
  // Case 3: Default - broadcast to message.type room and 'all' room
  // Send to each room separately instead of using an array
  io.to(message.type).emit('message', message);
  io.to('all').emit('message', message);
}
```

The key change is in Case 2 and Case 3, where we're now sending to each room separately instead of trying to pass an array of rooms to the `to()` method. This is more compatible with how Socket.IO's room broadcasting actually works and will resolve the timeout issues in your tests.

**The Problem:**
Socket.IO's `to()` method does accept an array in newer versions, but the implementation can be inconsistent in test environments. When you pass an array like `io.to([room1, room2])`, Socket.IO will internally interpret this differently than if you called `io.to(room1)` and `io.to(room2)` separately.

**Impact on Testing:**
When tests run, these subtle differences in broadcasting behavior can cause messages to not be received properly, leading to timeouts as the test waits for events that never arrive.

To fix your tests, also ensure you're using a consistent methodology for cleaning up resources:

```javascript
// In your test teardown function
afterEach(async () => {
  if (env && env.cleanup) {
    await env.cleanup();
  }
});

// And in your cleanup function
cleanup: () => {
  return new Promise<void>((resolve) => {
    // Force close all connections
    io.disconnectSockets(true);
    
    // Set a short timeout for the cleanup to finish
    const timeout = setTimeout(() => {
      console.log('Server close timed out, forcing exit');
      resolve();
    }, 300);
    
    // Close the server properly if possible
    server.close(() => {
      clearTimeout(timeout);
      resolve();
    });
    
    // Make sure Socket.IO server is properly closed
    try {
      io.close();
    } catch (e) {
      console.error('Error closing Socket.IO server:', e);
    }
  });
}
```

This approach ensures that even if there are lingering connections, your tests won't hang indefinitely.